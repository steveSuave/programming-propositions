<!DOCTYPE html>


<html lang="en-us" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>The Logical Operators In Lambda Calculus - Programming Propositions</title>

<meta name="description" content="Basic notions Lambda Calculus is a formal system introduced by Alonzo Church to study function abstraction and application. Church originally created this system in order to solve the Entscheidungsproblem. Its history and development is worth researching, this post however will only show how to understand basic lambda expressions and how to define a few logical operators inside this system.
Lambda Calculus gets its name from the Greek letter lambda λ which inside the system is called the abstraction operator and is used to bind variables in expressions.">





<link rel="icon" type="image/x-icon" href="https://stevesuave.github.io/programming-propositions/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://stevesuave.github.io/programming-propositions/favicon.png">


<style>
  body {
    visibility: hidden;
    opacity: 0;
  }
</style>

<noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>



    





    
    
        
    
    

    
        <link rel="stylesheet" href="https://stevesuave.github.io/programming-propositions/css/style.min.aac3b3a2a3235d20a652d9ccde7ec59be09f74c45de387513f681d02f3912b95.css" integrity="sha256-qsOzoqMjXSCmUtnM3n7Fm&#43;CfdMRd44dRP2gdAvORK5U=">
    





    

    





    
    
        
    
    

    
        <script src="https://stevesuave.github.io/programming-propositions/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js" type="text/javascript" charset="utf-8" integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script>
    







<meta property="og:title" content="The Logical Operators In Lambda Calculus" />
<meta property="og:description" content="Basic notions Lambda Calculus is a formal system introduced by Alonzo Church to study function abstraction and application. Church originally created this system in order to solve the Entscheidungsproblem. Its history and development is worth researching, this post however will only show how to understand basic lambda expressions and how to define a few logical operators inside this system.
Lambda Calculus gets its name from the Greek letter lambda λ which inside the system is called the abstraction operator and is used to bind variables in expressions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stevesuave.github.io/programming-propositions/posts/the-logical-operators-in-lambda-calculus/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T23:30:55+03:00" />
<meta property="article:modified_time" content="2022-10-21T23:30:55+03:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Logical Operators In Lambda Calculus"/>
<meta name="twitter:description" content="Basic notions Lambda Calculus is a formal system introduced by Alonzo Church to study function abstraction and application. Church originally created this system in order to solve the Entscheidungsproblem. Its history and development is worth researching, this post however will only show how to understand basic lambda expressions and how to define a few logical operators inside this system.
Lambda Calculus gets its name from the Greek letter lambda λ which inside the system is called the abstraction operator and is used to bind variables in expressions."/>











    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header"> 
            
                <div class="header-top">
    <h1 class="site-title">
    <a href="/programming-propositions">Programming Propositions</a>
</h1>
    <ul class="social-icons">


    
        
        
        <li>
            <a href="https://github.com/stevesuave" title="Github" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

</span>

            </a>
        </li>
    

    
        
        
        <li>
            <a href="mailto:s.levantes@gmail.com" title="Email" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"/></svg>

</span>

            </a>
        </li>
    



    <li>
            <a href="https://stevesuave.github.io/programming-propositions/index.xml" title="RSS" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg>

</span>

            </a>
        </li>
    

</ul>
</div>

    <nav>
        
        
        <a class="" href="https://stevesuave.github.io/programming-propositions/posts/" title="Archive">Archive</a>
        
        <a class="" href="https://stevesuave.github.io/programming-propositions/tags/" title="Tags">Tags</a>
        
        <a class="" href="https://stevesuave.github.io/programming-propositions/about/" title="About">About</a>
        
    </nav>


<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



            
        </header>
        <main id="main" tabindex="-1"> 
            
    

    <article class="post h-entry">
        <div class="post-header">
            <header>
                <h1 class="p-name post-title">The Logical Operators In Lambda Calculus</h1>

                
            </header>
        </div>
        <div class="content e-content">
            <h5 id="basic-notions" >Basic notions
<span>
    <a href="#basic-notions">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h5><p>Lambda Calculus is a formal system introduced by Alonzo Church to study function abstraction and application.
Church originally created this system in order to solve the Entscheidungsproblem. Its history and development is worth researching, this post however will only show how to understand basic lambda expressions and how to define a few logical operators inside this system.</p>
<p>Lambda Calculus gets its name from the Greek letter lambda λ which inside the system is called the <em>abstraction operator</em> and is used to bind variables in expressions.</p>
<p>A lambda function is an anonymous function and can be described in BNF notation as:
$$\langle function \rangle ::= \lambda \langle name \rangle . \langle expression \rangle$$
Where &rsquo;name&rsquo; denotes a bound variable (which may be any sequence of non-blank characters and can be thought of as the function&rsquo;s input), the dot &lsquo;.&rsquo; separates the bound variable from the expression (and from a programmer&rsquo;s viewpoint it can be read as &ldquo;return&rdquo;) and &rsquo;expression&rsquo; can be thought of as the function&rsquo;s body and may be a name, a function or a function application.</p>
<p><span style="font-size:14px"><em>Example: The identity function, simply return the input.</em></span><br>
$$\lambda x.x$$</p>
<p>A function application is simply two lambda expressions wrapped in parentheses (this is one of many different notations). The first expression being a function expression and the second an argument expression. The application specializes the abstraction by providing a value for the bound variable. The function is said to be applied to the argument.</p>
<p><span style="font-size:14px"><em>Example: Apply the identity function to the argument expression a. The bound variable &ldquo;x&rdquo; gets substituted with the value of &ldquo;a&rdquo; inside the function body. The abstraction operator (λx) at the left of the function body and the argument expression a at the right of the function body disappear. This expression simply evaluates to a.</em></span>
$$(\lambda x.x\hspace{12mu}a) \to a$$</p>
<p>In order to evaluate a function application we have to replace all occurrences of the bound variable inside the body by <strong>either</strong> the value of the argument expression <strong>or</strong> the unevaluated argument expression. The first approach is called <strong>applicative order</strong> reduction and the second <strong>normal order</strong> reduction. In this post I&rsquo;ll be using normal order to evaluate reductions.</p>
<h5 id="encoding-the-logical-operators" >Encoding the logical operators
<span>
    <a href="#encoding-the-logical-operators">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h5><p>The main entities of lambda calculus are functions, so this is what we have to encode the boolean values into. The way this has been achieved is by representing both True and False as lambda functions that accept two arguments. We should note here that the abstraction operator λ typically binds one variable at a time so a function of two variables would be notated $ \lambda a. \lambda b. \langle expression \rangle $, that is a function that takes one argument and returns a function that takes one argument and returns an expression.</p>
<ul>
<li><strong>True</strong>  returns the first  argument $$\lambda a. \lambda b.a$$</li>
<li><strong>False</strong> returns the second argument $$\lambda a. \lambda b.b$$</li>
</ul>
<p>Let&rsquo;s apply the identity function to the True function
$$(\lambda x.x \hspace{12mu} \lambda a. \lambda b.a) \to \lambda a. \lambda b.a$$
We may allow ourselves to use the abbreviation &ldquo;True&rdquo; instead of the whole lambda expression encoding it.
$$(\lambda x.x \hspace{12mu} True) \to True$$</p>
<p>Now, the <em>True</em> and <em>False</em> functions (being functions) can also be applied to arguments, and evidently they can be used to encode the <em>Not</em> operator.
Let&rsquo;s first see <em>True</em> being used as a function:
$$ ((True \hspace{6mu} foo)\hspace{6mu} bar) \to foo $$</p>
<p>Let&rsquo;s expand the leftmost True in order to see the substitution process.
$$ ((\lambda a.\lambda b. a \hspace{12mu} foo)\hspace{6mu} bar) \to $$
$$ (\lambda b. foo \hspace{12mu} bar) \to $$
$$ foo $$</p>
<!-- TODO: WALK THROUGH THE PROCESS -->
<p><em>Not</em> will be defined as a function expecting one boolean argument e.g. $\lambda x$ and returning the opposite boolean value. We saw that the boolean values are encoded as functions expecting two (arbitrary) arguments, and we want to achieve:</p>
<!-- |X    |Not X| -->
<!-- |:----|:----| -->
<!-- |True |False| -->
<!-- |False|True | -->
<table style="margin-left: auto; margin-right: auto;">
  <tr><th>X</th> <th>Not X</th>
  <tr><td>True</td> <td>False</td>
  <tr><td>False</td> <td>True</td>
</table>
<p>So this x bound variable will have to become either <em>True</em> or <em>False</em>. And since <em>True</em> and <em>False</em> are functions expecting two arguments, one of which will be returned, we will have to provide two boolean arguments (to <em>Not</em>&rsquo;s input) in some order that achieves <em>Not</em>&rsquo;s truth table.<br>
Let&rsquo;s define <em>Not</em> as $$\lambda x.((x \hspace{6mu} False) \hspace{6mu} True)$$ and try to apply it to <em>True</em>:
$$(\lambda x.((x \hspace{6mu} False) \hspace{6mu} True) \hspace{6mu} True) \to$$
$$((True \hspace{6mu} False) \hspace{6mu} True)\to$$
$$ False $$</p>
<p>From here on I will be less explanatory and briefly define the <em>And</em>, <em>Or</em>, <em>Implies</em> and <em>Equivalent</em> operators in abbreviated boolean lambda terms. I will leave the expansion as a pastime suggestion to the reader. One could also consider defining <em>Xor</em>, <em>Nand</em> etc.</p>
<p>$$ And = \lambda a. \lambda b.(a \hspace{6mu} b \hspace{6mu} False) $$
$$ Or = \lambda a. \lambda b.(a \hspace{6mu} True \hspace{6mu} b) $$
$$ Implies = \lambda a. \lambda b.(a \hspace{6mu} b \hspace{6mu} True) $$
$$ Equiv = \lambda a. \lambda b.(a \hspace{6mu} b \hspace{6mu} ( Not \hspace{6mu} b)) $$</p>
<hr>
<h5 id="paralipomena" >Paralipomena
<span>
    <a href="#paralipomena">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h5><p>A variable in a lambda expression is said to be &ldquo;free&rdquo; if it is not “bound” by a λ. An expression is closed if it has no free variables, otherwise it is open.<br>
Formally, the replacement of a bound variable with an argument in a function body is called <strong>beta reduction</strong> (β-reduction).<br>
When an expression can be reduced by applying a function to an argument it is called a <em>redex</em>. When an expression contains no redexes it is said to be in <em>normal form</em>.</p>
<ul>
<li>Normal-order reduction: Choose the left-most redex first.</li>
<li>Applicative-order reduction: Choose the right-most redex first.</li>
</ul>
<p>Other google-worthy notions: α-conversion, η-reduction</p>
<!-- --- -->
<!-- **Implies** and **Equivalent** truth tables -->
<!-- <table style="display: inline-block; margin-left: auto; margin-right: auto;"> -->
<!--   <tr><th>X</th> <th>X</th> <th>X Implies Y</th> -->
<!--   <tr><td>False</td> <td>False</td> <td>True</td> -->
<!--   <tr><td>False</td> <td>True</td> <td>True</td> -->
<!--   <tr><td>True</td> <td>False</td> <td>False</td> -->
<!--   <tr><td>True</td> <td>True</td> <td>True</td> -->
<!-- </table> -->
<!-- <table style="display: inline-block; margin-left: auto; margin-right: auto;"> -->
<!--   <tr><th>X</th> <th>X</th> <th>X Equiv Y</th> -->
<!--   <tr><td>False</td> <td>False</td> <td>True</td> -->
<!--   <tr><td>False</td> <td>True</td> <td>False</td> -->
<!--   <tr><td>True</td> <td>False</td> <td>False</td> -->
<!--   <tr><td>True</td> <td>True</td> <td>True</td> -->
<!-- </table> -->
<hr>
<h5 id="resources" >Resources
<span>
    <a href="#resources">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h5><p><a href="https://www.cs.rochester.edu/~brown/173/readings/LCBook.pdf">https://www.cs.rochester.edu/~brown/173/readings/LCBook.pdf</a><br>
<a href="https://www.cs.yale.edu/homes/hudak/CS201S08/lambda.pdf">https://www.cs.yale.edu/homes/hudak/CS201S08/lambda.pdf</a><br>
<a href="https://www.cs.cornell.edu/courses/cs312/2008sp/recitations/rec26.html">https://www.cs.cornell.edu/courses/cs312/2008sp/recitations/rec26.html</a><br>
<a href="https://plato.stanford.edu/entries/lambda-calculus/">https://plato.stanford.edu/entries/lambda-calculus/</a></p>
<!-- Let's see for this case the whole reduction in lambda terms. After this we will only use the abbreviations for simplicity and readability. -->
<!-- $$ ((\lambda a. \lambda b.a \hspace{14mu} \lambda i. \lambda j.i)\hspace{14mu} \lambda x. \lambda y.y) \to $$ -->
<!-- $$ ( \lambda b. \lambda i. \lambda j.i \hspace{14mu} \lambda x. \lambda y.y) \to $$ -->
<!-- $$ \lambda i. \lambda j.i $$ -->
<!-- Bound variable a will be substituted by $ \lambda i. \lambda j.i $ in the function body a of the left inner parenthesis. Bound variable b does not appear in the body so it will just be ignored. -->
<!-- $$ \to \lambda ab.a $$ -->

        </div>
        

    


<div class="post-info">
    
        <div class="post-date dt-published">2022-10-21</div>
    

    <a class="post-hidden-url u-url" href="https://stevesuave.github.io/programming-propositions/posts/the-logical-operators-in-lambda-calculus/">https://stevesuave.github.io/programming-propositions/posts/the-logical-operators-in-lambda-calculus/</a>
    <a href="https://stevesuave.github.io/programming-propositions/" class="p-name p-author post-hidden-author h-card" rel="me">Stefanos Levantes</a>


    <div class="post-taxonomies">
        
            
                <ul class="post-tags">
                    
                        
                        <li><a href="https://stevesuave.github.io/programming-propositions/tags/logical-operators/">#logical-operators</a></li>
                    
                        
                        <li><a href="https://stevesuave.github.io/programming-propositions/tags/lambda-calculus/">#lambda-calculus</a></li>
                    
                </ul>
        
    </div>
</div>

    </article>

    
        
        
    

    
        



    

    
        







    

        </main>
        
            <footer class="common-footer">
    
    

    <div class="common-footer-bottom">
        
        <div class="copyright">
            <p>© Stefanos Levantes, 2022<br>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.<br>
            
            </p>  
        </div> 

        

    



    <button class="theme-switcher">
        Dark theme
    </button>


<script>
const STORAGE_KEY = 'user-color-scheme'
const defaultTheme = "light"

let currentTheme
let switchButton
let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

const autoChangeScheme = e => {
    currentTheme = e.matches ? 'dark' : 'light'
    document.documentElement.setAttribute('data-theme', currentTheme)
    changeButtonText()
}

document.addEventListener('DOMContentLoaded', function() {
    switchButton = document.querySelector('.theme-switcher')
    currentTheme = detectCurrentScheme()
    if (currentTheme == 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark')
    }
    if (currentTheme == 'auto') {
        autoChangeScheme(autoDefinedScheme);
        autoDefinedScheme.addListener(autoChangeScheme);
    }

    if (switchButton) {
        changeButtonText()
        switchButton.addEventListener('click', switchTheme, false)
    }
  
    showContent()
})

function detectCurrentScheme() {
    if (localStorage.getItem(STORAGE_KEY)) {
        return localStorage.getItem(STORAGE_KEY)
    } 
    if (defaultTheme) {
        return defaultTheme
    } 
    if (!window.matchMedia) {
        return 'light'
    } 
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark'
    }
    return 'light'
}

function changeButtonText()
{   
    if (switchButton) {
        switchButton.textContent = currentTheme == 'dark' ?  "Light theme" : "Dark theme"
    }
}

function switchTheme(e) {
    if (currentTheme == 'dark') {
        localStorage.setItem(STORAGE_KEY, 'light')
        document.documentElement.setAttribute('data-theme', 'light')
        currentTheme = 'light'
    } else {
        localStorage.setItem(STORAGE_KEY, 'dark')
        document.documentElement.setAttribute('data-theme', 'dark')
        currentTheme = 'dark'
    }
    changeButtonText()
}

function showContent() {
    document.body.style.visibility = 'visible';
    document.body.style.opacity = 1;
}
</script>   
    </div>

    <p class="h-card vcard">

    <a href=https://stevesuave.github.io/programming-propositions/ class="p-name u-url url fn" rel="me">Stefanos Levantes</a> 

     
        /
        <a class="p-email u-email email" rel="me" href="mailto:s.levantes@gmail.com">s.levantes@gmail.com</a>
    

     
        <img class="u-photo" src="/images/me.png" />
    
</p> 
</footer>

        
    </div>
</body>
</html>
